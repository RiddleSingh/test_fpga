# -*- coding: utf-8 -*-
"""KS_GPU_FINAL - JumpSearch - 2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1fqzP6DetrF7NzkrfW0eFrya8HwVQw3KC
"""

# Commented out IPython magic to ensure Python compatibility.
# %reset -f
import numpy as np
from numba import cuda
from scipy import stats
import math
import time
import cupy as cp
import numba
from numba.types import int32, float64, uint32, uint8

"""# **Functions_OLD**

## **Interpolation Functions**
"""

def binary_search1(p,x,x_dim):
    idx_min = 0
    idx_max = x_dim - 1
    
    idx_m = int((idx_min + idx_max) / 2)
    
    if p < x[idx_min] or p > x[idx_max] : 
        raise ValueError
    
    while idx_min < idx_m :
        if p <= x[idx_m] : 
            idx_max = idx_m
        else : 
            idx_min = idx_m
        idx_m = int((idx_min + idx_max) / 2)
    return idx_min, idx_max

def find_range1(p,x,x_dim):
  for ii in range(2,x_dim):
    if p < x[ii-1] :
      idx_min = ii - 2
      idx_max = ii - 1
      return idx_min, idx_max
  return x_dim-2, x_dim-1

def linear_interp4d1(points,values,qp):
    x0 = points[0]
    x1 = points[1]
    x2 = points[2]
    x3 = points[3]
    x0_dim = x0.size
    x1_dim = x1.size
    x2_dim = x2.size
    x3_dim = x3.size
    
    i0_min, i0_max = find_range1(qp[0], x0, x0_dim)
    i1_min, i1_max = find_range1(qp[1], x1, x1_dim)
    i2_min, i2_max = find_range1(qp[2], x2, x2_dim)
    i3_min, i3_max = find_range1(qp[3], x3, x3_dim)
    
    #0:min, 1:max
    f_0000 = values[IXV1(i0_min, i1_min, i2_min, i3_min)]
    f_1000 = values[IXV1(i0_max, i1_min, i2_min, i3_min)]
    f_0100 = values[IXV1(i0_min, i1_max, i2_min, i3_min)]
    f_0010 = values[IXV1(i0_min, i1_min, i2_max, i3_min)]
    f_0001 = values[IXV1(i0_min, i1_min, i2_min, i3_max)]
    f_1100 = values[IXV1(i0_max, i1_max, i2_min, i3_min)]
    f_1010 = values[IXV1(i0_max, i1_min, i2_max, i3_min)]
    f_1001 = values[IXV1(i0_max, i1_min, i2_min, i3_max)]
    f_0110 = values[IXV1(i0_min, i1_max, i2_max, i3_min)]
    f_0101 = values[IXV1(i0_min, i1_max, i2_min, i3_max)]
    f_0011 = values[IXV1(i0_min, i1_min, i2_max, i3_max)]
    f_1110 = values[IXV1(i0_max, i1_max, i2_max, i3_min)]
    f_1101 = values[IXV1(i0_max, i1_max, i2_min, i3_max)]
    f_1011 = values[IXV1(i0_max, i1_min, i2_max, i3_max)]
    f_0111 = values[IXV1(i0_min, i1_max, i2_max, i3_max)]
    f_1111 = values[IXV1(i0_max, i1_max, i2_max, i3_max)]
    
    #weights
    tx = (qp[0] - x0[i0_min]) / (x0[i0_max] - x0[i0_min])
    ty = (qp[1] - x1[i1_min]) / (x1[i1_max] - x1[i1_min])
    tz = (qp[2] - x2[i2_min]) / (x2[i2_max] - x2[i2_min])
    tw = (qp[3] - x3[i3_min]) / (x3[i3_max] - x3[i3_min])
    
    fp = f_0000 * (1-tx) * (1-ty) * (1-tz) * (1-tw) + \
         f_1000 *    tx  * (1-ty) * (1-tz) * (1-tw) + \
         f_0100 * (1-tx) *    ty  * (1-tz) * (1-tw) + \
         f_0010 * (1-tx) * (1-ty) *    tz  * (1-tw) + \
         f_0001 * (1-tx) * (1-ty) * (1-tz) *    tw  + \
         f_1100 *    tx  *    ty  * (1-tz) * (1-tw) + \
         f_1010 *    tx  * (1-ty) *    tz  * (1-tw) + \
         f_1001 *    tx  * (1-ty) * (1-tz) *    tw  + \
         f_0110 * (1-tx) *    ty  *    tz  * (1-tw) + \
         f_0101 * (1-tx) *    ty  * (1-tz) *    tw  + \
         f_0011 * (1-tx) * (1-ty) *    tz  *    tw  + \
         f_1110 *    tx  *    ty  *    tz  * (1-tw) + \
         f_1101 *    tx  *    ty  * (1-tz) *    tw  + \
         f_1011 *    tx  * (1-ty) *    tz  *    tw  + \
         f_0111 * (1-tx) *    ty  *    tz  *    tw  + \
         f_1111 *    tx  *    ty  *    tz  *    tw
    
    return fp

def linear_interp2d1(points,values,qp):
    x0 = points[0]
    x1 = points[1]
    x0_dim = x0.size
    x1_dim = x1.size
       
    i0_min, i0_max = find_range1(qp[0], x0, x0_dim)
    i1_min, i1_max = find_range1(qp[1], x1, x1_dim)
    
    #0:min, 1:max
    f_00 = values[IXID1(i0_min, i1_min)] 
    f_10 = values[IXID1(i0_max, i1_min)]
    f_01 = values[IXID1(i0_min, i1_max)]
    f_11 = values[IXID1(i0_max, i1_max)]
    
    #weights
    tx = (qp[0] - x0[i0_min]) / (x0[i0_max] - x0[i0_min])
    ty = (qp[1] - x1[i1_min]) / (x1[i1_max] - x1[i1_min])
    
    fp = f_00 * (1-tx) * (1-ty) + \
         f_10 *    tx  * (1-ty) + \
         f_01 * (1-tx) *    ty  + \
         f_11 *    tx  *    ty 
        
    return fp

def linear_interp2daux1(points,values,qp,ia,iid):
    x0 = points[0]
    x1 = points[1]
    x0_dim = x0.size
    x1_dim = x1.size
       
    i0_min, i0_max = find_range1(qp[0], x0, x0_dim)
    i1_min, i1_max = find_range1(qp[1], x1, x1_dim)
    
    #0:min, 1:max
    f_00 = values[IXV1(ia,i0_min,iid,i1_min)] 
    f_10 = values[IXV1(ia,i0_max,iid,i1_min)]
    f_01 = values[IXV1(ia,i0_min,iid,i1_max)]
    f_11 = values[IXV1(ia,i0_max,iid,i1_max)]
    
    #weights
    tx = (qp[0] - x0[i0_min]) / (x0[i0_max] - x0[i0_min])
    ty = (qp[1] - x1[i1_min]) / (x1[i1_max] - x1[i1_min])
    
    fp = f_00 * (1-tx) * (1-ty) + \
         f_10 *    tx  * (1-ty) + \
         f_01 * (1-tx) *    ty  + \
         f_11 *    tx  *    ty 
        
    return fp

def linear_interp2daux1(points,values,qp,ia,iid):
    x0 = points[0]
    x1 = points[1]
    x0_dim = x0.size
    x1_dim = x1.size
       
    i0_min, i0_max = find_range1(qp[0], x0, x0_dim)
    i1_min, i1_max = find_range1(qp[1], x1, x1_dim)
    
    #0:min, 1:max
    for ia in range(nstates_ag) :
      for iid in range(nstates_id) :
        f_00 = values[IXV1(ia,i0_min,iid,i1_min)]
        f_10 = values[IXV1(ia,i0_max,iid,i1_min)]
        f_01 = values[IXV1(ia,i0_min,iid,i1_max)]
        f_11 = values[IXV1(ia,i0_max,iid,i1_max)]
        #weights
        tx = (qp[0] - x0[i0_min]) / (x0[i0_max] - x0[i0_min])
        ty = (qp[1] - x1[i1_min]) / (x1[i1_max] - x1[i1_min])
        fp = f_00 * (1-tx) * (1-ty) + \
            f_10 *    tx  * (1-ty) + \
            f_01 * (1-tx) *    ty  + \
            f_11 *    tx  *    ty
        kprime2[IXAI1(ia,iid)] = fp
        
    return kprime2

def linear_interpaux1(points,values,qp,agshock,t):    
    i0_min, i0_max = find_range1(qp, points, points.size)
    kid = ngridk * nstates_id
    kprimet = np.zeros(kid,np.float64)
    aa = int(agshock[t])
    
    for ik in range(ngridk):
      for iid in range(nstates_id):
        f_0 = values[IXV1(aa,i0_min,iid,ik)]
        f_1 = values[IXV1(aa,i0_max,iid,ik)]
        #weights
        w = (qp - points[i0_min]) / (points[i0_max] - points[i0_min])
        fp = ((1-w) * f_0) + (w * f_1)
        kprimet[IXID1(iid,ik)] = fp
    return kprimet

"""## **Position Arguments**"""

#current and future aggregate/idiosyncratic shocks
def IXP1(a,i,ap,ip):
    ixp = nstates_id * nstates_ag * nstates_id * a \
        + nstates_ag * nstates_id * i\
        + nstates_id * ap\
        + ip
    return ixp
#aggregate/idiosyncratic shocks and individuals
def IXEV1(a,i,j):
    ixev = nstates_id * ngridk * a\
        + ngridk * i\
        + j
    return ixev
#aggregate shocks, mean-capital grids, idiosyncratic shocks and captial grids
def IXV1(a,km,i,k): 
    ixv = ngridkm * nstates_id * ngridk * a\
        + nstates_id * ngridk * km\
        + ngridk * i\
        + k
    return ixv
#time periods and individuals
def IX1(t,j):
    ix = t * N + j
    return ix
#idiosyncratic shocks and capital grids
def IXID1(i,k):
    ixid = i * ngridk + k
    return ixid
#aggregate shocks and mean-capital grids
def IXAKM1(a,km):
    ixakm = a * ngridkm + km
    return ixakm
#aggregate/idiosyncratic shocks
def IXAI1(a,i):
    ixai = a * nstates_id + i
    return ixai
#capital/mean-capital
def IXKKM1(k,km):
  ixkkm1 = k * ngridkm + km
  return ixkkm1

"""## **Cuda Functions**"""

@cuda.jit(device=True)
def binary_search(p,x,x_dim):
    idx_min = 0
    idx_max = x_dim - 1
    
    idx_m = int((idx_min + idx_max) / 2)
    
    if p < x[idx_min] or p > x[idx_max] : 
        raise ValueError
    
    while idx_min < idx_m :
        if p <= x[idx_m] : 
            idx_max = idx_m
        else : 
            idx_min = idx_m
        idx_m = int((idx_min + idx_max) / 2)
    return idx_min, idx_max

@cuda.jit(defice=True)
def find_range(p,x,x_dim):
  for ii in range(2,x_dim):
    if p < x[ii-1] :
      idx_min = ii - 2
      idx_max = ii - 1
      return idx_min, idx_max
  return x_dim-2, x_dim-1

#4-D linear interpolation on a list of points
@cuda.jit(device=True)
def linear_interp4d(points,values,qp):
    x0 = points[0]
    x1 = points[1]
    x2 = points[2]
    x3 = points[3]
    x0_dim = x0.size
    x1_dim = x1.size
    x2_dim = x2.size
    x3_dim = x3.size
    
    i0_min, i0_max = find_range(qp[0], x0, x0_dim)
    i1_min, i1_max = find_range(qp[1], x1, x1_dim)
    i2_min, i2_max = find_range(qp[2], x2, x2_dim)
    i3_min, i3_max = find_range(qp[3], x3, x3_dim)
    
    #0:min, 1:max
    f_0000 = values[IXV(i0_min, i1_min, i2_min, i3_min)]
    f_1000 = values[IXV(i0_max, i1_min, i2_min, i3_min)]
    f_0100 = values[IXV(i0_min, i1_max, i2_min, i3_min)]
    f_0010 = values[IXV(i0_min, i1_min, i2_max, i3_min)]
    f_0001 = values[IXV(i0_min, i1_min, i2_min, i3_max)]
    f_1100 = values[IXV(i0_max, i1_max, i2_min, i3_min)]
    f_1010 = values[IXV(i0_max, i1_min, i2_max, i3_min)]
    f_1001 = values[IXV(i0_max, i1_min, i2_min, i3_max)]
    f_0110 = values[IXV(i0_min, i1_max, i2_max, i3_min)]
    f_0101 = values[IXV(i0_min, i1_max, i2_min, i3_max)]
    f_0011 = values[IXV(i0_min, i1_min, i2_max, i3_max)]
    f_1110 = values[IXV(i0_max, i1_max, i2_max, i3_min)]
    f_1101 = values[IXV(i0_max, i1_max, i2_min, i3_max)]
    f_1011 = values[IXV(i0_max, i1_min, i2_max, i3_max)]
    f_0111 = values[IXV(i0_min, i1_max, i2_max, i3_max)]
    f_1111 = values[IXV(i0_max, i1_max, i2_max, i3_max)]
    
    #weights
    tx = (qp[0] - x0[i0_min]) / (x0[i0_max] - x0[i0_min])
    ty = (qp[1] - x1[i1_min]) / (x1[i1_max] - x1[i1_min])
    tz = (qp[2] - x2[i2_min]) / (x2[i2_max] - x2[i2_min])
    tw = (qp[3] - x3[i3_min]) / (x3[i3_max] - x3[i3_min])
    
    fp = f_0000 * (1-tx) * (1-ty) * (1-tz) * (1-tw) + \
         f_1000 *    tx  * (1-ty) * (1-tz) * (1-tw) + \
         f_0100 * (1-tx) *    ty  * (1-tz) * (1-tw) + \
         f_0010 * (1-tx) * (1-ty) *    tz  * (1-tw) + \
         f_0001 * (1-tx) * (1-ty) * (1-tz) *    tw  + \
         f_1100 *    tx  *    ty  * (1-tz) * (1-tw) + \
         f_1010 *    tx  * (1-ty) *    tz  * (1-tw) + \
         f_1001 *    tx  * (1-ty) * (1-tz) *    tw  + \
         f_0110 * (1-tx) *    ty  *    tz  * (1-tw) + \
         f_0101 * (1-tx) *    ty  * (1-tz) *    tw  + \
         f_0011 * (1-tx) * (1-ty) *    tz  *    tw  + \
         f_1110 *    tx  *    ty  *    tz  * (1-tw) + \
         f_1101 *    tx  *    ty  * (1-tz) *    tw  + \
         f_1011 *    tx  * (1-ty) *    tz  *    tw  + \
         f_0111 * (1-tx) *    ty  *    tz  *    tw  + \
         f_1111 *    tx  *    ty  *    tz  *    tw
    
    return fp

@cuda.jit(device=True)
def linear_interp2d(points,values,qp):
    x0 = points[0]
    x1 = points[1]
    x0_dim = x0.size
    x1_dim = x1.size
       
    i0_min, i0_max = find_range(qp[0], x0, x0_dim)
    i1_min, i1_max = find_range(qp[1], x1, x1_dim)
    
    #0:min, 1:max
    f_00 = values[IXID(i0_min, i1_min)] 
    f_10 = values[IXID(i0_max, i1_min)]
    f_01 = values[IXID(i0_min, i1_max)]
    f_11 = values[IXID(i0_max, i1_max)]
    
    #weights
    tx = (qp[0] - x0[i0_min]) / (x0[i0_max] - x0[i0_min])
    ty = (qp[1] - x1[i1_min]) / (x1[i1_max] - x1[i1_min])
    
    fp = f_00 * (1-tx) * (1-ty) + \
         f_10 *    tx  * (1-ty) + \
         f_01 * (1-tx) *    ty  + \
         f_11 *    tx  *    ty 
        
    return fp

@cuda.jit(device=True)
def linear_interp2d2(points,values,qp):
    x0 = points[0]
    x1 = points[1]
    x0_dim = x0.size
    x1_dim = x1.size

    i0_min, i0_max = find_range(qp[0], x0, x0_dim)
    i1_min, i1_max = find_range_100(qp[1], x1)        # kgrid
    '''
    i0_min, i0_max = find_range_4(qp[0], x0)          #kmgrid
    i0_min, i0_max = find_range(qp[0], x0, x0_dim)
    i1_min, i1_max = find_range(qp[1], x1, x1_dim)
    '''
    #0:min, 1:max
    f_00 = values[IXKKM(i0_min, i1_min)] 
    f_10 = values[IXKKM(i0_max, i1_min)]
    f_01 = values[IXKKM(i0_min, i1_max)]
    f_11 = values[IXKKM(i0_max, i1_max)]
    
    #weights
    tx = (qp[0] - x0[i0_min]) / (x0[i0_max] - x0[i0_min])
    ty = (qp[1] - x1[i1_min]) / (x1[i1_max] - x1[i1_min])
    
    fp = f_00 * (1-tx) * (1-ty) + \
         f_10 *    tx  * (1-ty) + \
         f_01 * (1-tx) *    ty  + \
         f_11 *    tx  *    ty 
        
    return fp

@cuda.jit(device=True)
def linear_interp2daux(points,values,qp,ia,iid):
    x0 = points[0]
    x1 = points[1]
    x0_dim = x0.size
    x1_dim = x1.size
       
    i0_min, i0_max = find_range(qp[0], x0, x0_dim)
    i1_min, i1_max = find_range(qp[1], x1, x1_dim)
    
    #0:min, 1:max
    f_00 = values[IXV(ia,i0_min,iid,i1_min)] 
    f_10 = values[IXV(ia,i0_max,iid,i1_min)]
    f_01 = values[IXV(ia,i0_min,iid,i1_max)]
    f_11 = values[IXV(ia,i0_max,iid,i1_max)]
    
    #weights
    tx = (qp[0] - x0[i0_min]) / (x0[i0_max] - x0[i0_min])
    ty = (qp[1] - x1[i1_min]) / (x1[i1_max] - x1[i1_min])
    
    fp = f_00 * (1-tx) * (1-ty) + \
         f_10 *    tx  * (1-ty) + \
         f_01 * (1-tx) *    ty  + \
         f_11 *    tx  *    ty 
        
    return fp

@cuda.jit(device=True)
def linear_interp2daux2(points,values,qp,kprime2aux):
    x0 = points[0]
    x1 = points[1]
    x0_dim = x0.size
    x1_dim = x1.size
       
    i0_min, i0_max = find_range(qp[0], x0, x0_dim)
    i1_min, i1_max = find_range(qp[1], x1, x1_dim)
    
    #0:min, 1:max
    for ia in range(nstates_ag) :
      for iid in range(nstates_id) :
        f_00 = values[IXV(ia,i0_min,iid,i1_min)]
        f_10 = values[IXV(ia,i0_max,iid,i1_min)]
        f_01 = values[IXV(ia,i0_min,iid,i1_max)]
        f_11 = values[IXV(ia,i0_max,iid,i1_max)]
        #weights
        tx = (qp[0] - x0[i0_min]) / (x0[i0_max] - x0[i0_min])
        ty = (qp[1] - x1[i1_min]) / (x1[i1_max] - x1[i1_min])
        fp = f_00 * (1-tx) * (1-ty) + \
            f_10 *    tx  * (1-ty) + \
            f_01 * (1-tx) *    ty  + \
            f_11 *    tx  *    ty
        kprime2aux[IXAI(ia,iid)] = fp
        
    return kprime2aux

#current and future aggregate/idiosyncratic shocks
@cuda.jit(device=True)
def IXP(a,i,ap,ip):
    ixp = nstates_id * nstates_ag * nstates_id * a \
        + nstates_ag * nstates_id * i\
        + nstates_id * ap\
        + ip
    return ixp
#aggregate/idiosyncratic shocks and individuals
@cuda.jit(device=True)
def IXEV(a,i,j):
    ixev = nstates_id * ngridk * a\
        + ngridk * i\
        + j
    return ixev
#aggregate shocks, mean-capital grids, idiosyncratic shocks and captial grids
@cuda.jit(device=True)
def IXV(a,km,i,k): 
    ixv = ngridkm * nstates_id * ngridk * a\
        + nstates_id * ngridk * km\
        + ngridk * i\
        + k
    return ixv
#time periods and individuals
@cuda.jit(device=True)
def IX(t,j):
    ix = t * N + j
    return ix
#idiosyncratic shocks and capital grids
@cuda.jit(device=True)
def IXID(i,k):
    ixid = i * ngridk + k
    return ixid
#aggregate shocks and mean-capital grids
@cuda.jit(device=True)
def IXAKM(a,km):
    ixakm = a * ngridkm + km
    return ixakm
#aggregate/idiosyncratic shocks
@cuda.jit(device=True)
def IXAI(a,i):
    ixai = a * nstates_id + i
    return ixai
#capital/mean-capital
@cuda.jit(device=True)
def IXKKM(k,km):
  ixkkm = k * ngridkm + km
  return ixkkm

"""## **Main Cuda Functions**"""

@cuda.jit
def individual(kprime,kprimen,kmprime):
  #thread positioning
  tx = cuda.threadIdx.x #thread id
  ty = cuda.blockIdx.x #block id
  bw = cuda.blockDim.x #block dimension
  pos = (ty * bw) + tx #global thread id
  
  dim1 = ngridk * ngridkm * nstates_ag
  dim2 = ngridk * ngridkm
  
  iid = int(math.floor( pos / dim1 ))
  ia = int(math.floor( (pos - iid * dim1) / dim2 ))
  ikm = int(math.floor( (pos - iid * dim1 - ia * dim2) / ngridk))
  ik = pos - iid * dim1 - ia * dim2 - ikm * ngridk

  kmp = kmprime[IXAKM(ia,ikm)]
  kp = kprime[IXV(ia,ikm,iid,ik)]
  points = (km,k)
  qp = (kmp,kp)

  EMU = 0
  for iap in range(nstates_ag) :
    urp = ur[iap]
    erp = er[iap]
    ir = alpha * a[iap] * ((kmp/(erp*l_bar)) ** (alpha-1))
    imrt = (1-delta+ir)
    w = (1-alpha) * a[iap] * ((kmp/(erp*l_bar))**alpha)
    for iidp in range(nstates_id) :
      k2 = linear_interp2daux(points,kprime,qp,iap,iidp)
      ep = epsilon[iidp]
      c2 = (imrt*kp) - k2 + (w*ep*l_bar - mu*w*(urp/(1-urp)))*iidp + (mu*w)*(1-iidp)
      MU2 = c2 ** (-gamma)
      EMU += Pr[IXP(ia,iid,iap,iidp)] * imrt * MU2
  cn = (beta * EMU) ** (-1/gamma)
  kprimen[IXV(ia,ikm,iid,ik)] = wealth[IXV(ia,ikm,iid,ik)] - cn
  if kprimen[IXV(ia,ikm,iid,ik)] > k_max :
    kprimen[IXV(ia,ikm,iid,ik)] = k_max
  if kprimen[IXV(ia,ikm,iid,ik)] < k_min :
    kprimen[IXV(ia,ikm,iid,ik)] = k_min

@cuda.jit
def Aggregate_ST(kcrossn,kprimet,eps):
  tx2 = cuda.threadIdx.x #thread id
  ty2 = cuda.blockIdx.x #block id
  bw2 = cuda.blockDim.x #block dimension
  ij = (ty2 * bw2) + tx2 #global thread id
  kcrossn[ij] = linear_interp2d2((epsilon,k),kprimet,(eps[ij],kcrossn[ij]))
  if kcrossn[ij] > k_max :
    kcrossn[ij] = k_max
  if kcrossn[ij] < k_min :
    kcrossn[ij] = k_min

def indiv_it(kprime,B) :
  dif_k = 1
  iter_dk = 0
  for ia in range(nstates_ag):
    const_coef = ia * regressors
    km_coef = ia * regressors + 1
    for ikm in range(ngridkm):
        kmprime[IXAKM1(ia,ikm)] = np.exp(B[const_coef] + (B[km_coef] * np.log(km[ikm])))
        if kmprime[IXAKM1(ia,ikm)] > km_max :
            kmprime[IXAKM1(ia,ikm)] = km_max
        if kmprime[IXAKM1(ia,ikm)] < km_min : 
            kmprime[IXAKM1(ia,ikm)] = km_min   
  kprimen = np.zeros(nstates,np.float64)
  start1 = time.time()
  while dif_k>toll_k :
    individual[threadsperblock1,blockspergrid1](kprime,kprimen,kmprime)
    dif_k = np.max(np.abs(kprimen-kprime))
    kprime = update_k * kprimen + (1-update_k) * kprime
    iter_dk += 1
  elapsed1 = time.time() - start1
  print("Individual {}, {} iterations, {} seconds".format(it+1,iter_dk,elapsed1))
  c = wealth - kprime
  return kprime, c

def indiv_it1(kprime,B) :
  dif_k = 1
  iter_dk = 0
  for ia in range(nstates_ag):
    const_coef = ia * regressors
    km_coef = ia * regressors + 1
    for ikm in range(ngridkm):
        kmprime[IXAKM1(ia,ikm)] = np.exp(B[const_coef] + (B[km_coef] * np.log(km[ikm])))
        if kmprime[IXAKM1(ia,ikm)] > km_max :
            kmprime[IXAKM1(ia,ikm)] = km_max
        if kmprime[IXAKM1(ia,ikm)] < km_min : 
            kmprime[IXAKM1(ia,ikm)] = km_min   
  kprimen = np.zeros(nstates,np.float64)
  start1 = time.time()
  while dif_k>toll_k :
    individual[threadsperblock1,blockspergrid1](kprime,kprimen,kmprime)
    # Wait until all threads finish computing
    cuda.syncthreads()
    dif_k = np.max(np.abs(kprimen-kprime))
    kprime = update_k * kprimen + (1-update_k) * kprime
    iter_dk += 1
  elapsed1 = time.time() - start1
  print("Individual {}, {} iterations, {} seconds".format(it+1,iter_dk,elapsed1))
  c = wealth - kprime
  return kprime, c

def ag_st(kcross,kprime) :
  kcrossn = kcross
  kmts = np.zeros(T,np.float64)
  start2 = time.time()
  for t in range(T):
    kmts[t] = kcrossn.mean()
    if kmts[t] > km_max :
      kmts[t] = km_max
    if kmts[t] < km_min :
      kmts[t] = km_min
    kprimet = linear_interpaux1(km,kprime,kmts[t],agshock,t)
    Aggregate_ST[threadsperblock2,blockspergrid2](kcrossn,kprimet,idshock[t,:])
  elapsed2 = time.time() - start2
  print("Aggregate {}, {} seconds".format(it+1,elapsed2))
  return kmts,kcrossn

def ag_st_new(kcross,kprime) : 
  # CPUs array
  kcrossn=kcross
  kmts = np.zeros(T,np.float64) 
  # GPU permanent inputs: agshock (1100x1), idshocks (1100x10000): always the same
  # GPU: temporary inputs: kcross (10000x1) kprime
  Aggregate_ST_new[threadsperblock2,blockspergrid2](agshock,idshock,kprime,kmts,kcrossn)
  # Returns: kmts (1100x1), kcrossn (10000,1)

@cuda.jit
def Aggregate_ST_new(agshock,idshock,kprime,kmts,kcross): 
  tx2 = cuda.threadIdx.x #thread id
  ty2 = cuda.blockIdx.x #block id
  bw2 = cuda.blockDim.x #block dimension
  ij = (ty2 * bw2) + tx2 #global absolute thread id (core index)
  for t in range(T):
    # Compute the mean
    kmts_mean = kcross.mean()
    if kmts_mean > km_max :
      kmts_mean = km_max
    if kmts_mean < km_min :
      kmts_mean = km_min
    kmts[t] = kmts_mean
    cuda.syncthreads()
    kprimet = np.zeros(400)
    if ij<N : # N=10000
      for ik in range(ngridk) :
        for ikm in range(ngridkm) :
          kprimet[IXKKM1(ik,ikm)] = kprime[IXV1(agshock[t],ikm,idshock[t,ij],ik)]
      kcrossn[ij] = linear_interp2d((k,km),kprimet,(kcross[ij],kmts_mean))
      if kcrossn[ij] > k_max :
        kcrossn[ij] = k_max
      if kcrossn[ij] < k_min :
        kcrossn[ij] = k_min
      kcross[ij] = kcrossn[ij]
      cuda.syncthreads()

"""# **CPU Functions**"""

#aggregate shocks and mean-capital grids
def IXAKM_CPU(a,km):
    ixakm = a * ngridkm + km
    return ixakm

#aggregate shocks, mean-capital grids, idiosyncratic shocks and captial grids
def IXV_CPU(a,km,i,k): 
    ixv = ngridkm * nstates_id * ngridk * a\
        + nstates_id * ngridk * km\
        + ngridk * i\
        + k
    return ixv

#current and future aggregate/idiosyncratic shocks
def IXP_CPU(a,i,ap,ip):
    ixp = nstates_id * nstates_ag * nstates_id * a \
        + nstates_ag * nstates_id * i\
        + nstates_id * ap\
        + ip
    return ixp

"""# **Model Setup**

## **Parameters**
"""

beta = 0.99 #Discount factor
gamma = 1 #Utility function parameter
alpha = 0.36 #Capital Share in production function
delta = 0.025 #Deperciation Rate
delta_a = 0.01 #Production level; bad state : "1-delta_a", good state : "1+delta_a"
mu = 0.15 #Unemployment benefits (as share of wage)
l_bar = 1/0.9 #Time endowment; normalizes to 1 in bad state

epsilon_u = 0 #Idiosyncratic Shock if Unemployed
epsilon_e = 1 #Idiosyncratic Shock if Employed
ur_b = 0.1 #Unemployment Rate in Bad State
ur_g = 0.04 #Unemployment Rate in Good State
er_b = (1 - ur_b) #Employment Rate in Bad State
er_g = (1 - ur_g) #Employment Rate in Good State
kss = ((1/beta - (1-delta))/alpha)**(1/(alpha-1)) #Steady State Capital

"""## **States**"""

N = 10000 #Number of agents
T = 1100 #Period length
nstates_id = 2 #Number of States for the Idiosyncratic Shock
nstates_ag = 2 #Number of States for the Aggregate Shock
ngridk = 100 #Number of grids for k
ngridkm = 4 #Number of grids for m
nstates = nstates_id * nstates_ag * ngridk * ngridkm
grid = np.array([nstates_ag,ngridkm,nstates_id,ngridk]) #for gpu position argument in interpolation (not allocated yet)

#employment status array
epsilon = np.zeros(nstates_id)
epsilon[0] = epsilon_u
epsilon[1] = epsilon_e
#employment status array for stochastic simulation
epsilon2 = np.zeros(nstates_id)
epsilon2[0] = 1
epsilon2[1] = 2
#aggregate productivity shock array
a = np.zeros(nstates_ag)
a[0] = 1 - delta_a
a[1] = 1 + delta_a
#aggregate productivity shock array for stochastic simulation
a2 = np.zeros(nstates_ag)
a2[0] = 0
a2[1] = 1
#unemployment rate array
ur = np.zeros(nstates_ag)
ur[0] = ur_b
ur[1] = ur_g
#employment rate array
er = np.zeros(nstates_ag)
er[0] = er_b
er[1] = er_g
#kcross
kcross = np.zeros(N) + kss

"""## **Convergence Parameters**"""

#Convergence Parameters
toll_k = 1e-8
update_k = 0.7
toll_coeff = 1e-8
update_b = 0.3
ndiscard = 100

#parameters array (for individual)
params = np.array([alpha,l_bar,delta,mu,gamma,beta,update_k])

"""## **Shocks**"""

#Import Shocks
idshock = np.genfromtxt("/scratch/alpine/alpe9373/CCE-GPU/input/idshock.csv",dtype=np.uint8,delimiter=',')
idshock = idshock - 1
agshock = np.genfromtxt("/scratch/alpine/alpe9373/CCE-GPU/input/agshock.csv",dtype=np.uint8,delimiter=',')
agshock = agshock - 1

#agshock=np.random.randint(0,1,size=T,dtype='uint8')
#idshock=np.random.randint(0,1,size=(T,N),dtype='uint8')

"""## **$k∈[0,k_{max}]$, $m\in[m_{min},m_{max}]$**"""

k_min = 0.
k_max = 1000.
# CUDA kernels do not return anything, so you have to supply for an array to be modified. 
# All arguments have to be arrays, if you work with scalars, make them arrays of length one. 
k_min_aux_gpu = np.full(1,k_min) #np.zeros(1,dtype='float64')
k_max_aux_gpu = np.full(1,k_max)

x = np.linspace(0,0.5,ngridk)
y = (x**7) / np.max(x**7)

#Interval for k
k = k_min + ((k_max - k_min) * y)

km_min = 30.
km_max = 50.

#Interval for m
km = np.linspace(km_min,km_max,ngridkm)

"""## **Transition Matrix**"""

#Transition Matrix
Pr = np.zeros(IXP_CPU(nstates_ag-1,nstates_id-1,nstates_ag-1,nstates_id))          
Pr[IXP_CPU(0,0,0,0)] = 0.525
Pr[IXP_CPU(0,0,0,1)] = 0.35
Pr[IXP_CPU(0,0,1,0)] = 0.03125
Pr[IXP_CPU(0,0,1,1)] = 0.09375
Pr[IXP_CPU(0,1,0,0)] = 0.038889
Pr[IXP_CPU(0,1,0,1)] = 0.836111
Pr[IXP_CPU(0,1,1,0)] = 0.002083
Pr[IXP_CPU(0,1,1,1)] = 0.122917
Pr[IXP_CPU(1,0,0,0)] = 0.09375
Pr[IXP_CPU(1,0,0,1)] = 0.03125
Pr[IXP_CPU(1,0,1,0)] = 0.291667
Pr[IXP_CPU(1,0,1,1)] = 0.583333
Pr[IXP_CPU(1,1,0,0)] = 0.009115
Pr[IXP_CPU(1,1,0,1)] = 0.115885
Pr[IXP_CPU(1,1,1,0)] = 0.024306
Pr[IXP_CPU(1,1,1,1)] = 0.850694

""" Old Version
#Transition Matrix
Pr = np.zeros(IXP1(nstates_ag-1,nstates_id-1,nstates_ag-1,nstates_id))          
Pr[IXP1(0,0,0,0)] = 0.525
Pr[IXP1(0,0,0,1)] = 0.35
Pr[IXP1(0,0,1,0)] = 0.03125
Pr[IXP1(0,0,1,1)] = 0.09375
Pr[IXP1(0,1,0,0)] = 0.038889
Pr[IXP1(0,1,0,1)] = 0.836111
Pr[IXP1(0,1,1,0)] = 0.002083
Pr[IXP1(0,1,1,1)] = 0.122917
Pr[IXP1(1,0,0,0)] = 0.09375
Pr[IXP1(1,0,0,1)] = 0.03125
Pr[IXP1(1,0,1,0)] = 0.291667
Pr[IXP1(1,0,1,1)] = 0.583333
Pr[IXP1(1,1,0,0)] = 0.009115
Pr[IXP1(1,1,0,1)] = 0.115885
Pr[IXP1(1,1,1,0)] = 0.024306
Pr[IXP1(1,1,1,1)] = 0.850694
"""

"""## **Wealth and Initial $k'$**"""

trate = np.zeros(nstates_ag)
irate = np.zeros(IXAKM1(nstates_ag-1,ngridkm))
wage = np.zeros(IXAKM1(nstates_ag-1,ngridkm))
wealth = np.zeros(IXV1(nstates_ag-1,ngridkm-1,nstates_id-1,ngridk))
kprime = np.zeros(IXV1(nstates_ag-1,ngridkm-1,nstates_id-1,ngridk))

for ia in range(nstates_ag):
    #Tax Rate
    trate[ia] = mu * (1 - er[ia]) / er[ia]
    tr = trate[ia]
    for ikm in range(ngridkm):
        #Interest Rate
        irate[IXAKM1(ia,ikm)] = alpha * a[ia] * ((km[ikm]/(er[ia]*l_bar)) ** (alpha-1))
        ir = irate[IXAKM1(ia,ikm)]
        #Wage
        wage[IXAKM1(ia,ikm)] = (1-alpha) * a[ia] * ((km[ikm]/er[ia]/l_bar)**alpha)
        w = wage[IXAKM1(ia,ikm)]
        for iid in range(nstates_id):
            for ik in range(ngridk):
                #Wealth
                wealth[IXV1(ia,ikm,iid,ik)] = ((1-delta+ir) * k[ik])\
                                            + (w*l_bar - mu*w*((1-er[ia])/er[ia]))*epsilon[iid]\
                                            + mu*w*(1-epsilon[iid])
                #kprime
                kprime[IXV1(ia,ikm,iid,ik)] = 0.9 * k[ik]

"""## **Initial Aggregate Law of Motion**"""

kmprime = np.zeros(IXAKM1(nstates_ag-1,ngridkm))
B = np.array([0,1,0,1])
regressors = 2

"""# **Functions_GPU**

## **Position Arguments_GPU**
"""

#grid = [nstates_ag,ngridkm,nstates_id,ngridk]

############################# Used for Individual #############################

#aggregate shocks and mean-capital grids
@cuda.jit(device=True)
def IXAKM_GPU(a,km,grid):
    ixakm = a * grid[1] + km
    return int(ixakm)

@cuda.jit(device=True)
def IXV_GPU(a,km,i,k,grid): ##also used in aggregate_st, but name is IXVGPU
    ixv = grid[1] * grid[2] * grid[3] * a\
        + grid[2] * grid[3] * km\
        + grid[3] * i\
        + k
    return int(ixv)

#current and future aggregate/idiosyncratic shocks
@cuda.jit(device=True)
def IXP_GPU(a,i,ap,ip,grid):
    ixp = grid[2] * grid[0] * grid[2] * a \
        + grid[0] * grid[2] * i\
        + grid[2] * ap\
        + ip
    return int(ixp)

#aggregate/idiosyncratic shocks
@cuda.jit(device=True)
def IXAI_GPU(a,i,grid):
    ixai = a * grid[2] + i
    return ixai

"""## **Find Range**"""

@cuda.jit(device=True)
def find_range_100(p,x):
  if(p == x[0]):
    return 0, 1
  elif(p > x[99]):  
    return 98, 99
  else:
    result_1=0
    result_2=0
    result_3=0
    for ii in range(99,0, -20):     # 99 to 0, skip 20 (Search over 100):   99 79 59 39 19 0
      if ii<0:
        ii=0
      if (p <= x[ii]):
        result_1 = ii
    for ii in range(4,0, -1):     # 4 comparators, skip 5 (search over 20)
      if (p <= x[result_1]):
        result_2 = result_1
      result_1 = result_1 - 5
    for ii in range(5,0, -1):     # 5 comparators, skip 1 (search over 5)
      if (p <= x[result_2]):
        result_3 = result_2
      result_2 = result_2-1
    return result_3-1, result_3

@cuda.jit(device=True)
def find_range_4(p,x):
  for ii in range(2,4):
    if p < x[ii-1] :
      idx_min = ii - 2
      idx_max = ii - 1
      return idx_min, idx_max
  return 2, 3

@cuda.jit(device=True)
def find_range(p,x,x_dim):
  for ii in range(2,x_dim):
    if p < x[ii-1] :
      idx_min = ii - 2
      idx_max = ii - 1
      return idx_min, idx_max
  return x_dim-2, x_dim-1

"""# **Individual**

## **Interpolation Indv**
"""

@cuda.jit(device=True)
def linear_interp2d_ind(points,values,qp,grid,ia,iid):
    x0 = points[0]
    x1 = points[1]
    x0_dim = x0.size
    x1_dim = x1.size

    i0_min, i0_max = find_range(qp[0], x0, x0_dim)    #kmgrid
    i1_min, i1_max = find_range_100(qp[1], x1)        # kgrid
    '''
    i0_min, i0_max = find_range_4(qp[0], x0)          #kmgrid
    i0_min, i0_max = find_range(qp[0], x0, x0_dim)    #kmgrid
    i1_min, i1_max = find_range(qp[1], x1, x1_dim)
    '''
    
    #0:min, 1:max
    f_00 = values[IXV_GPU(ia,i0_min,iid,i1_min,grid)]
    f_10 = values[IXV_GPU(ia,i0_max,iid,i1_min,grid)]
    f_01 = values[IXV_GPU(ia,i0_min,iid,i1_max,grid)]
    f_11 = values[IXV_GPU(ia,i0_max,iid,i1_max,grid)]
    #weights
    tx = (qp[0] - x0[i0_min]) / (x0[i0_max] - x0[i0_min])
    ty = (qp[1] - x1[i1_min]) / (x1[i1_max] - x1[i1_min])
    #compute
    fp = f_00 * (1-tx) * (1-ty) + \
         f_10 *    tx  * (1-ty) + \
         f_01 * (1-tx) *    ty  + \
         f_11 *    tx  *    ty 
        
    return fp

"""## **Individual Kernel**"""

@cuda.jit
def ind_ker(kprime_gpu,kmprime_gpu,kprimen_gpu,grid_gpu,trate_gpu,irate_gpu,wage_gpu,wealth_gpu,k_gpu,km_gpu,ur_gpu,er_gpu,a_gpu,epsilon_gpu,Pr_gpu,params_gpu,dif_k_gpu,k_max_gpu,k_min_gpu):
  pos = cuda.grid(1)

  if pos < len(kprime_gpu) :
    #grid = [nstates_ag,ngridkm,nstates_id,ngridk]
    nstates_ag = int(grid_gpu[0])
    ngridkm = int(grid_gpu[1])
    nstates_id = int(grid_gpu[2])
    ngridk = int(grid_gpu[3])

    dim1 = ngridk * ngridkm * nstates_ag
    dim2 = ngridk * ngridkm
  
    iid = int(math.floor( pos / dim1 ))
    ia = int(math.floor( (pos - iid * dim1) / dim2 ))
    ikm = int(math.floor( (pos - iid * dim1 - ia * dim2) / ngridk))
    ik = pos - iid * dim1 - ia * dim2 - ikm * ngridk

    #params = [alpha,l_bar,delta,mu,gamma,beta,update_k]
    alpha_gpu = params_gpu[0]
    l_bar_gpu = params_gpu[1]
    delta_gpu = params_gpu[2]
    mu_gpu = params_gpu[3]
    gamma_gpu = params_gpu[4]
    beta_gpu = params_gpu[5]
    update_k_gpu = params_gpu[6]

    k_min_local = cuda.local.array(1,'float64')
    k_max_local = cuda.local.array(1,'float64')

    k_min_local = k_min_gpu[0]  
    k_max_local = k_max_gpu[0]  
 
    kmp = kmprime_gpu[IXAKM_GPU(ia,ikm,grid_gpu)]
    kp = kprime_gpu[IXV_GPU(ia,ikm,iid,ik,grid_gpu)]
  
    EMU = cuda.local.array(1,'float64')
    EMU = 0.
    for iap in range(nstates_ag) :
      urp = ur_gpu[iap]
      erp = er_gpu[iap]
      ir = alpha_gpu * a_gpu[iap] * ((kmp/(erp*l_bar_gpu)) ** (alpha_gpu-1))
      imrt = (1 - delta_gpu + ir)
      w = (1-alpha_gpu) * a_gpu[iap] * ((kmp/(erp*l_bar_gpu))**alpha_gpu)
      for iidp in range(nstates_id) :
        k2 = linear_interp2d_ind((km_gpu,k_gpu),kprime_gpu,(kmp,kp),grid_gpu,iap,iidp)
        ep = epsilon_gpu[iidp]
        c2 = (imrt*kp) - k2 + (w*ep*l_bar_gpu - mu_gpu*w*(urp/(1-urp)))*iidp + (mu_gpu*w)*(1-iidp)
        MU2 = c2 ** (-gamma_gpu)
        ixp_gpu = int(IXP_GPU(ia,iid,iap,iidp,grid_gpu))
        EMU += Pr_gpu[ixp_gpu] * imrt * MU2
    cn = (beta_gpu * EMU) ** (-1/gamma_gpu)

    indx_local = cuda.local.array(1,'uint32')
    indx_local = IXV_GPU(ia,ikm,iid,ik,grid_gpu)

    kprimen_gpu[indx_local] = wealth_gpu[indx_local] - cn
    if kprimen_gpu[indx_local] > k_max_local :
      kprimen_gpu[indx_local] = k_max_local
    if kprimen_gpu[indx_local] < k_min_local :
      kprimen_gpu[indx_local] = k_min_local
    
    dif_k_gpu[indx_local] = kprimen_gpu[indx_local] - kprime_gpu[indx_local]
    if dif_k_gpu[indx_local] >= 0 :
      dif_k_gpu[indx_local] = dif_k_gpu[indx_local]
    else :
      dif_k_gpu[indx_local] = - dif_k_gpu[indx_local]
            
    kprime_gpu[indx_local] = update_k_gpu * kprimen_gpu[indx_local] + (1-update_k_gpu) * kprime_gpu[indx_local]
    cuda.syncthreads()

"""## **Idividual Main**"""

def indiv_main(kmprime,kprime,B):
  #kmprime setup
  for ia in range(nstates_ag):
    const_coef = ia * regressors
    km_coef = ia * regressors + 1
    for ikm in range(ngridkm):
      kmprime[IXAKM_CPU(ia,ikm)] = np.exp(B[const_coef] + (B[km_coef] * np.log(km[ikm])))
      if kmprime[IXAKM_CPU(ia,ikm)] > km_max :
        kmprime[IXAKM_CPU(ia,ikm)] = km_max
      if kmprime[IXAKM_CPU(ia,ikm)] < km_min :
        kmprime[IXAKM_CPU(ia,ikm)] = km_min
  #kprimen setup
  kprimen = kprime.copy()
  dif_k = kprime.copy()
  #to device : kprimen,kmprime,kprime
  kprimen_gpu = cuda.to_device(kprimen.astype(dtype='float64'))
  kmprime_gpu = cuda.to_device(kmprime.astype(dtype='float64'))
  dif_k_gpu = cuda.to_device(dif_k.astype(dtype='float64'))
  kprime_gpu = cuda.to_device(kprime.astype(dtype='float64')) ## also used in aggregate_st, but should be different

  mdif_k = 1.
  start1 = time.time()
  while mdif_k > toll_k :
    ind_ker[config1](kprime_gpu,kmprime_gpu,kprimen_gpu,grid_gpu,trate_gpu,irate_gpu,wage_gpu,wealth_gpu,k_gpu,km_gpu,ur_gpu,er_gpu,a_gpu,epsilon_gpu,Pr_gpu,params_gpu,dif_k_gpu,k_max_gpu,k_min_gpu)
    mdif_k_gpu = cp.max(cp.asarray(dif_k_gpu,dtype='float64'))
    mdif_k = cp.asnumpy(mdif_k_gpu)
  kprime=cp.asnumpy(kprime_gpu)
  elapsed1 = time.time() - start1
  print("Individual {}, {} seconds".format(it+1,elapsed1))
  return kprime

"""# **Aggregate_ST**

## **Interpolation AG_ST**
"""

@cuda.jit
def linear_interp2d2(points,kprime,qp,ia,iid,grid):
  x0 = points[0]
  x1 = points[1]
  x0_dim = x0.size
  x1_dim = x1.size
  i0_min, i0_max = find_range(qp[0], x0, x0_dim)
  i1_min, i1_max = find_range_100(qp[1], x1)        # kgrid
  #i1_min, i1_max = find_range(qp[1], x1, x1_dim)

  #0:min, 1:max
  f_00 = kprime[IXV_GPU(ia,i0_min,iid,i1_min,grid)] 
  f_10 = kprime[IXV_GPU(ia,i0_max,iid,i1_min,grid)]
  f_01 = kprime[IXV_GPU(ia,i0_min,iid,i1_max,grid)]
  f_11 = kprime[IXV_GPU(ia,i0_max,iid,i1_max,grid)]

  #weights
  tx = (qp[0] - x0[i0_min]) / (x0[i0_max] - x0[i0_min])
  ty = (qp[1] - x1[i1_min]) / (x1[i1_max] - x1[i1_min])
    
  fp = f_00 * (1-tx) * (1-ty) + \
       f_10 *    tx  * (1-ty) + \
       f_01 * (1-tx) *    ty  + \
       f_11 *    tx  *    ty 

  return fp

"""## **Aggregate_ST Kernal**"""

###############################################################################
############################# AGGREGATE_ST KERNAL #############################
###############################################################################
@cuda.jit
def ag_st_ker(t,k_min_gpu,k_max_gpu,agshock_gpu,idshock_gpu,kcross_gpu,kcrossn_gpu,k_gpu,km_gpu,kprime_gpu,kmts_gpu,grid_gpu):
  ij = cuda.grid(1)   

  k_min_local = cuda.local.array(1,'float64')
  k_max_local = cuda.local.array(1,'float64')

  k_min_local = k_min_gpu[0]  
  k_max_local = k_max_gpu[0]   

  if ij < len(kcross_gpu):
    
    kcross_local = cuda.local.array(1,'float64')
    kmts_local = cuda.local.array(1,'float64')
    ia_local = cuda.local.array(1,'uint8')
    iid_local = cuda.local.array(1,'uint8')
    
    kcross_local = kcross_gpu[ij]
    kmts_local = kmts_gpu[t]
    ia_local = agshock_gpu[t]
    iid_local = idshock_gpu[t,ij]
    
    kcrossn_gpu[ij] = linear_interp2d2((km_gpu,k_gpu),kprime_gpu,(kmts_local,kcross_local),ia_local,iid_local,grid_gpu)
    
    if kcrossn_gpu[ij] < k_min_local:
        kcrossn_gpu[ij] =  k_min_local
    elif kcrossn_gpu[ij] > k_max_local:
        kcrossn_gpu[ij] =  k_max_local
    kcross_gpu[ij] = kcrossn_gpu[ij]
    cuda.syncthreads()

###############################################################################
############################## AGGREGATE_ST MAIN ##############################
###############################################################################
def ag_st_main(kcross,kprime,km_min_gpu,km_max_gpu,grid_gpu,km_gpu,k_gpu,k_min_gpu,k_max_gpu,agshock_gpu,idshock_gpu):
  start2 = time.time()
  '''
  kmts = np.zeros(T)
  kcrossn = kcross.copy() 
  # cupy arrays.
  kmts_gpu = cuda.to_device(kmts.astype(dtype='float64')) 
  # cuda arrays
  kprime_gpu = cuda.to_device(kprime.astype(dtype='float64'))
  kcross_gpu = cuda.to_device(kcross.astype(dtype='float64'))
  kcrossn_gpu = cuda.to_device(kcrossn.astype(dtype='float64'))
  kcrossn_gpu_cp = cp.asarray(kcrossn_gpu)
  '''
  kprime_gpu = cuda.to_device(kprime.astype(dtype='float64'))
############################# AGGREGATE_ST KERNAL #############################
  for t in range(T): #check!!! should be range(T)
    kmts_gpu[t] = cp.mean(kcrossn_gpu_cp) 
    if kmts_gpu[t] > km_max_gpu:
      kmts_gpu[t] = km_max_gpu
    if kmts_gpu[t] < km_min_gpu:
      kmts_gpu[t] = km_min_gpu
    ag_st_ker[config2](t,k_min_gpu,k_max_gpu,agshock_gpu,idshock_gpu,kcross_gpu,kcrossn_gpu,k_gpu,km_gpu,kprime_gpu,kmts_gpu,grid_gpu)
###############################################################################
  # COPY BACK  
  kcrossn=kcrossn_gpu.copy_to_host() 
  kmts=cp.asnumpy(kmts_gpu)
  elapsed2 = time.time() - start2
  print("Aggregate {}, {} seconds".format(it+1,elapsed2))
  return kmts,kcrossn

"""# **Main**

## **GPU Set Up**
"""

# GPU specs : Individual
threadsperblock1 = 128 
blockspergrid1 = np.ceil(nstates / threadsperblock1).astype('int')
config1 = [threadsperblock1,blockspergrid1]

# GPU specs : Aggregate_ST
threadsperblock2 = 100 
blockspergrid2 = np.ceil(N / threadsperblock2).astype('int')
config2 = [threadsperblock2,blockspergrid2]

############################### to_device ONCE! ###############################

# used for both
k_min_gpu=cuda.to_device(k_min_aux_gpu.astype(dtype='float64'))
k_max_gpu=cuda.to_device(k_max_aux_gpu.astype(dtype='float64'))
km_gpu=cuda.to_device(km.astype(dtype='float64'))
k_gpu=cuda.to_device(k.astype(dtype='float64'))
grid_gpu=cp.asarray(grid)

# used for individual
params_gpu = cuda.to_device(params.astype(dtype='float64'))
trate_gpu = cuda.to_device(trate.astype(dtype='float64'))
irate_gpu = cuda.to_device(irate.astype(dtype='float64'))
wage_gpu = cuda.to_device(wage.astype(dtype='float64'))
wealth_gpu = cuda.to_device(wealth.astype(dtype='float64'))
ur_gpu = cuda.to_device(ur.astype(dtype='float64'))
er_gpu = cuda.to_device(er.astype(dtype='float64'))
a_gpu = cuda.to_device(a.astype(dtype='float64'))
epsilon_gpu = cuda.to_device(epsilon.astype(dtype='float64'))
Pr_gpu = cuda.to_device(Pr.astype(dtype='float64'))

# used for aggregate_st
km_min_gpu=cp.asarray(km_min)
km_max_gpu=cp.asarray(km_max)
agshock_gpu=cuda.to_device(agshock.astype(dtype='uint8'))
idshock_gpu=cuda.to_device(idshock.astype(dtype='uint8')) 

kmts = np.zeros(T)
kcrossn = kcross.copy() 
# cupy arrays.
kmts_gpu = cuda.to_device(kmts.astype(dtype='float64')) 
# cuda arrays
#kprime_gpu = cuda.to_device(kprime.astype(dtype='float64'))
kcross_gpu = cuda.to_device(kcross.astype(dtype='float64'))
kcrossn_gpu = cuda.to_device(kcrossn.astype(dtype='float64'))
kcrossn_gpu_cp = cp.asarray(kcrossn_gpu)

"""## **Main Iteration**"""

dif_B = 99999999
it = 0
init_time = time.time()
while dif_B > toll_coeff : #check!!! needs to be dif_B > toll_coeff
  kprime = indiv_main(kmprime,kprime,B)
  #kmts, kcross1 = ag_st(kcross,kprime) 
  kmts,kcross1 = ag_st_main(kcross,kprime,km_min_gpu,km_max_gpu,grid_gpu,km_gpu,k_gpu,k_min_gpu,k_max_gpu,agshock_gpu,idshock_gpu)
  
  ibad,igood = 0,0
  xbad,ybad,xgood,ygood = [],[],[],[]
    
  for i in range(ndiscard,T-1):
    if agshock[i] == 0:
      ibad = ibad + 1
      xbad.append(np.log(kmts[i]))
      ybad.append(np.log(kmts[i+1]))
    else:
      igood = igood +1
      xgood.append(np.log(kmts[i]))
      ygood.append(np.log(kmts[i+1]))
  xbad = np.array(xbad)
  ybad = np.array(ybad)
  xgood = np.array(xgood)
  ygood = np.array(ygood)
    
  res1,res2 = stats.linregress(xbad,ybad), stats.linregress(xgood,ygood)
  B1 = np.array([res1[1],res1[0],res2[1],res2[0]])
  R2bad,R2good = res1[2]**2, res2[2]**2

  dif_B = np.linalg.norm(B-B1)
    
  if dif_B > toll_coeff * 100 :
    kcross = kcross1
    
  B = B1*update_b + B*(1-update_b)
  it = it + 1
  print("---Iteration {}, dif_B = {}".format(it,dif_B))
  print(" ")
elapsed3 = time.time() - init_time
print("Total Iterations = {}, Total Time = {}".format(it,elapsed3))

def find_range_100_CPU(p,x):
  if(p == x[0]):
    return 0, 1
  elif(p > x[99]):  
    return 98, 99
  else:
    result_1=0
    result_2=0
    result_3=0
    for ii in range(99,0, -20):     # 99 to 0, skip 20 (Search over 100):   99 79 59 39 19 0
      if ii<0:
        ii=0
      if (p <= x[ii]):
        result_1 = ii
    for ii in range(4,-1, -1):     # 4 comparators, skip 5 (search over 20)
      if (p <= x[result_1]):
        result_2 = result_1   
      result_1 = result_1 - 5
    for ii in range(5,-1, -1):     # 5 comparators, skip 1 (search over 5)
      if (p <= x[result_2]):
        result_3 = result_2
      result_2 = result_2-1
    return result_3-1, result_3
def find_range(p,x,x_dim):
  for ii in range(2,x_dim):
    if p < x[ii-1] :
      idx_min = ii - 2
      idx_max = ii - 1
      return idx_min, idx_max
  return x_dim-2, x_dim-1

p = 99.7
x = np.arange(0.,200.,2)
for ii in range(0,100):
  print(ii,' ',x[ii])
start = time.time()  
imin,imax = find_range_100_CPU(p,x)    
end = time.time()
start1 = time.time()  
imin1,imax2 = find_range(p,x,len(x))    
end1 = time.time()


'''
for ii in range(99,0,-20):
  if ii<0:
    ii=0
  print(ii)
  p =52
x = np.arange(0,100,1)
result_1=59
result_2=0
result_3=0
for ii in range(4,-1, -1):     # 4 comparators, skip 5 (search over 20)
  if (p <= x[result_1]):
    result_2 = result_1   
  result_1 = result_1 - 5
  #print(result_1, ' ', result_2)  
for ii in range(5,-1, -1):     # 5 comparators, skip 1 (search over 5)
  if (p <= x[result_2]):
    result_3 = result_2
  result_2 = result_2-1  
print(result_3)
print('[',imin,',',imax,'] time:',start-end)
print('[',imin1,',',imax2,'] time:',start1-end1,'ratio: ',(start1-end1)/(start-end))
'''
