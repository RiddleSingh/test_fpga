
#######################################################################################
.PHONY: help
help:
	@echo "Makefile Usage:"
	@echo "" ................................................
	@echo "  make afi FPGA_BIN=<> HOST_BIN=<>"
	@echo "      Generate the fpga binary and host binary to run on AWS F1 instance. E.g. make afi FPGA_BIN=3ker_100k_4km HOST_BIN=1200_3ker_100k_4km"
	@echo ""
	@echo "  make openmpi OPENMPI_EXE=<>"
	@echo "      Generate the design for parallel execution on AWS CPU clusters using OPENMPI."
	@echo ""
	@echo "  make cpu "
	@echo "      Generate the design for serial execution on CPU."
	@echo ""
	@echo "  make cpu_seq CPU_EXE=app_1200_100k_4km"
	@echo "      Command to generate the design for serial execution on CPU using g++"
	@echo ""
	@echo "  make fpga TARGET=<sw_emu|hw>"
	@echo "      Generate the design for specified Target and Device."
	@echo ""
	@echo "  make clean "
	@echo "      Remove the generated files."
	@echo ""
	@echo "  make validate "
	@echo "      Compare the between files between CPU and FPGA"
	@echo ""
	@echo "  make zip "
	@echo "      Save the logs, reports and dcp file to a single zip file"
	@echo ""
	@echo "  make fpga_results TABLE=<3/4/5/all> USE_AWS_S3_EXE=<yes/no>"
	@echo "      Runs the host and fpga binaries for all the respective tables and save the results to AWS S3 bucket"
	@echo "      If we pass USE_AWS_S3_EXE=yes, the script copies the executables from the AWS instance to the f1 instance"
	@echo "      If not, we use the pre-built executables in the executables/fpga folder"
	@echo ""
	@echo "  make cpu_results M5N=<1x/1xBATCH1/1xBATCH2/1xBATCH3/4x/24x> USE_AWS_S3_EXE=<yes/no>"
	@echo "      Run the openmpi executables for all the grid points and saves the results to AWS S3 bucket"
	@echo "      If we pass USE_AWS_S3_EXE=yes, the script copies the executables from the AWS instance to the m5n instance"
	@echo "      If not, we use the pre-built executables in the executables/cpu folder"
	@echo ""
#######################################################################################
#SHELL := /bin/bash

# List of all executables for this paper
VALID_AFI_NAMES := 1ker_100k_4km 1ker_200k_4km 1ker_300k_4km 1ker_100k_8km 1ker_200k_8km 1ker_300k_8km 3ker_100k_4km 3ker_200k_4km 3ker_300k_4km 3ker_100k_8km 3ker_200k_8km 2ker_300k_8km baseline_1ker_100k_4km pipeline_1ker_100k_4km within_economy_1ker_100k_4km
VALID_HOST_BIN_NAMES := 1200_1ker_100k_4km 1200_1ker_200k_4km 1200_1ker_300k_4km 1200_1ker_100k_8km 1200_1ker_200k_8km 1200_1ker_300k_8km 1200_3ker_100k_4km 1200_3ker_200k_4km 1200_3ker_300k_4km 1200_3ker_100k_8km 1200_3ker_200k_8km 1200_2ker_300k_8km 120_1ker_100k_4km 120_3ker_100k_4km
VALID_OPENMPI_BIN_NAMES := 1200_100k_4km 1200_200k_4km 1200_300k_4km 1200_100k_8km 1200_200k_8km 1200_300k_8km 120_100k_4km 1200_linear 1200_binary 1200_custom_binary
VALID_CPU_BIN_NAMES := app_1200_100k_4km app_1200_200k_4km app_1200_300k_4km app_1200_100k_8km app_1200_200k_8km app_1200_300k_8km app_120_100k_4km app_1200_linear app_1200_binary

TARGET := hw
MPICXX := mpic++
CC := g++
FPGA_INCLUDES := -I./common -I./common/libs -I./fpga -I$(XILINX_XRT)/include -I$(XILINX_VIVADO)/include
CPU_INCLUDES  := -I./common -I./fpga
OPENMPI_INCLUDES  := -I./common -I./fpga
PLATFORM := xilinx_aws-vu9p-f1_shell-v04261818_201920_3
FPGA_FLAG := -D_FPGA_MODE
OPENMPI_FLAG := -D_OPENMPI_MODE
SERIAL_CPU_FLAG := -D_SERIAL_CPU_MODE

# Names of the executables / binaries
ifndef HOST_BIN
    HOST_EXE = host
else
	HOST_EXE = $(HOST_BIN)
endif

CPU_EXE ?= app
OPENMPI_EXE ?= openmpi_app
FPGA_EXE = runOnfpga
XO := ./fpga/build/$(FPGA_EXE).xo
XCLBIN := ./fpga/build/$(FPGA_EXE).xclbin

# Host building global settings
CXXFLAGS :=  $(FPGA_INCLUDES) -Wall -O3 -g -std=c++1y -fmessage-length=0 -L$(XILINX_XRT)/lib -pthread -lOpenCL -lrt -lstdc++   
CXXFLAGS2 := $(OPENMPI_INCLUDES) -Wall -O3 -g -std=c++1y -fmessage-length=0 -pthread -lrt -lstdc++  
CXXFLAGS3 := $(CPU_INCLUDES) -Wall -O3 -g -std=c++1y -fmessage-length=0 -pthread -lstdc++  

# Kernel compiler & linker global settings
KRNL_COMPILE_OPTS := -t $(TARGET) --config ./fpga/design.cfg --log_dir ./fpga/logs --report_dir ./fpga/reports --save-temps --jobs 8 --optimize 3
KRNL_LINK_OPTS := -t $(TARGET) --config ./fpga/design.cfg --log_dir ./fpga/logs --report_dir ./fpga/reports --save-temps --jobs 8 --optimize 3

# ---------------------- DEFINE BUCKETS FOR storing TEMPORARY and PERMANENT RESULTS
AWS_REGION := us-west-2

# 1. TEMPORARY BUCKET
S3_BUCKET_NAME := ksfpga-$(shell aws sts get-caller-identity | grep "Account" | tr -dc '0-9')
S3_DCP_DIR := vitis-dcps
S3_LOG_DIR := vitis-logs
S3_EXEC_DIR := executables

# 2. PERMANENT BUCKET
# AWS S3 stores the final executables and later final results
# fpga-econ-ks
#   - executables
#       - fpga
#           - fpga_afi
#           - host_executables
#       - cpu
#	- results (will be generated by make fpga_results, make cpu_results)
#		- fpga
#		- cpu
S3_EXE_BUCKET_NAME := fpga-econ-ks
S3_EXE_DIR := executables
S3_FPGA_DIR := $(S3_EXE_DIR)/fpga
S3_FPGA_AFI_DIR := $(S3_FPGA_DIR)/fpga_afi
S3_HOST_EXEC_DIR := $(S3_FPGA_DIR)/host_executables
S3_CPU_DIR := $(S3_EXE_DIR)/cpu

.PHONY: afi
afi: check_afi_variables create_s3_dirs afigen
# wait_for_afi.py script is not working, need to be fixed by AWS
#	. $(AWS_FPGA_REPO_DIR)/hdk_setup.sh; \
#	wait_for_afi.py --afi $(shell cat *afi_id.txt | sed -n '2p' | tr -d '",' | sed 's/.*://') --notify --email $(EMAIL) &

.PHONY: check_afi_variables
check_afi_variables:
ifndef FPGA_BIN
	$(error FPGA_BIN is not defined. Please specify a value for FPGA_BIN when invoking make afi.)
endif
ifndef HOST_BIN
	$(error HOST_BIN is not defined. Please specify a value for HOST_BIN when invoking make afi.)
endif
ifeq ($(filter $(FPGA_BIN),$(VALID_AFI_NAMES)),)
	$(error Invalid value for fpga afi name. Please use one of: $(VALID_AFI_NAMES))
endif
ifeq ($(filter $(HOST_BIN),$(VALID_HOST_BIN_NAMES)),)
	$(error Invalid value for host executable for f1.xx instance. Please use one of: $(VALID_HOST_BIN_NAMES))
endif

# Create Permanent Bucket if not already created
.PHONY: create_s3_dirs
create_s3_dirs:
# Check if the AWS CLI is configured
	@if ! aws configure get aws_access_key_id >/dev/null 2>&1; then \
		echo "Error: AWS CLI is not configured. Please run 'aws configure' to set up your AWS credentials before running this target."; \
		exit 1; \
	fi
		
# Check if the bucket exists
	@if ! aws s3 ls "s3://$(S3_EXE_BUCKET_NAME)" --region "$(AWS_REGION)"; then \
		aws s3 mb "s3://$(S3_EXE_BUCKET_NAME)" --region "$(AWS_REGION)"; \
	fi
	
# Create directories if they don't exist
	aws s3api put-object --bucket "$(S3_EXE_BUCKET_NAME)" --key "$(S3_FPGA_AFI_DIR)/" --region "$(AWS_REGION)" || true
	aws s3api put-object --bucket "$(S3_EXE_BUCKET_NAME)" --key "$(S3_HOST_EXEC_DIR)/" --region "$(AWS_REGION)" || true
	aws s3api put-object --bucket "$(S3_EXE_BUCKET_NAME)" --key "$(S3_CPU_DIR)/" --region "$(AWS_REGION)" || true

	@echo "Directories created or already exist."

.PHONY: afigen
afigen: fpga
	@if ! aws s3 ls s3://$(S3_BUCKET_NAME) --region $(AWS_REGION) > /dev/null 2>&1; then \
		aws s3 mb s3://$(S3_BUCKET_NAME) --region $(AWS_REGION); \
		touch FILES_GO_HERE.txt; \
		aws s3 cp FILES_GO_HERE.txt s3://$(S3_BUCKET_NAME)/$(S3_DCP_DIR)/; \
		touch LOGS_FILES_GO_HERE.txt; \
		aws s3 cp LOGS_FILES_GO_HERE.txt s3://$(S3_BUCKET_NAME)/$(S3_LOG_DIR)/; \
		touch EXECUTABLES_GO_HERE.txt; \
		aws s3 cp EXECUTABLES_GO_HERE.txt s3://$(S3_BUCKET_NAME)/$(S3_EXEC_DIR)/; \
	fi
	aws s3 ls s3://$(S3_BUCKET_NAME)/$(S3_BUCKET_PROJECT_FOLDER)
	rm -rf to_aws
#	Transform the .xclbin file to .awsxclbbin:
	$(VITIS_DIR)/tools/create_vitis_afi.sh -xclbin=$(XCLBIN) -s3_bucket=$(S3_BUCKET_NAME) -s3_dcp_key=$(S3_DCP_DIR) -s3_logs_key=$(S3_LOG_DIR)
#	Copy the executables host and .awsxclbin in the bucket to be then executed on the f1 instance.
#	Rename the fpga afi to the input name
	cp runOnfpga.awsxclbin $(FPGA_BIN).awsxclbin
	aws s3 cp $(HOST_EXE) s3://$(S3_EXE_BUCKET_NAME)/$(S3_HOST_EXEC_DIR)/
	aws s3 cp $(FPGA_BIN).awsxclbin s3://$(S3_EXE_BUCKET_NAME)/$(S3_FPGA_AFI_DIR)/

fpga:  $(XO) $(XCLBIN) $(HOST_EXE) emconfig

exe: $(HOST_EXE)

xclbin: $(XO) $(XCLBIN)

cpu: $(CPU_EXE)

.PHONY: cpu_seq
cpu_seq: check_cpu_variables create_s3_dirs $(CPU_EXE)
	aws s3 cp $(CPU_EXE) s3://$(S3_EXE_BUCKET_NAME)/$(S3_CPU_DIR)/

.PHONY: check_cpu_variables
check_cpu_variables:
ifeq ($(filter $(CPU_EXE),$(VALID_CPU_BIN_NAMES)),)
	$(error Invalid value for host executable for m5n.xx instance. Please specify CPU_EXE= one of: $(VALID_CPU_BIN_NAMES))
endif

.PHONY: openmpi
openmpi: check_openmpi_variables create_s3_dirs $(OPENMPI_EXE)
	aws s3 cp $(OPENMPI_EXE) s3://$(S3_EXE_BUCKET_NAME)/$(S3_CPU_DIR)/

.PHONY: check_openmpi_variables
check_openmpi_variables:
ifeq ($(filter $(OPENMPI_EXE),$(VALID_OPENMPI_BIN_NAMES)),)
	$(error Invalid value for host executable for m5n.xx instance. Please specify OPENMPI_EXE= one of: $(VALID_OPENMPI_BIN_NAMES))
endif

# Building kernel
$(XO): ./fpga/hw.cpp
	v++ -I./common -I./fpga -I./ $(FPGA_FLAG)  $(KRNL_COMPILE_OPTS) -c -k $(FPGA_EXE) -o'$@' '$<'

$(XCLBIN): $(XO)
	v++ -I./common -I./fpga -I./ $(KRNL_LINK_OPTS) -l  -o'$@' $(+)

# Building fpga Host for EGM until convergence
$(HOST_EXE): ./common/libs/xcl2.cpp ./common/app.cpp ./common/init.cpp
	$(CC) $(FPGA_FLAG)  $(CXXFLAGS) $^ -o $@

# Building and executing CPU executable using OpenMPI for EGM until convergence
$(OPENMPI_EXE): ./common/init.cpp ./common/app.cpp ./fpga/hw.cpp
	$(MPICXX) $(OPENMPI_FLAG)  $(CXXFLAGS2) $^ -o $@

# Building sequential CPU executable using g++ for EGM until convergence
$(CPU_EXE): ./common/init.cpp ./common/app.cpp ./fpga/hw.cpp
	$(CC) $(SERIAL_CPU_FLAG)  $(CXXFLAGS3) $^ -o $@

.PHONY: emconfig
emconfig:
	emconfigutil --platform $(PLATFORM)

.PHONY: clean
clean:
	$(RM) -rf *.csv *.jou *.run_summary *.dcp to_aws _x *.tar *.bin *.txt *.dSYM *.out 
	$(RM) *.o *~ rm -f $(HOST_EXE) $(CPU_EXE) $(OPENMPI_EXE) 
	$(RM) -rf *.log *.json *.xo .Xil/ .run/ runOnfpga* fpga/logs/ fpga/logs/link/* fpga/reports/* fpga/build/*
	$(RM) -rf ./results/cpu/*.txt ./results/cpu/log_results/*.txt ./results/cpu/final_values/*00.txt

.PHONY: validate
validate:
	python3 ./common/util/compare_results.py

.PHONY: zip
zip:
	sh ./common/util/save_results.sh

.PHONY: results_clean
results_clean:
	$(RM) -rf ./results/fpga/*.txt ./results/fpga/*.csv ./results/fpga/*.run_summary ./results/fpga/final_values/*.txt ./results/fpga/log_results/*.txt ./results/cpu/*.txt ./results/final_values/*.txt

.PHONY: fpga_results
fpga_results:
	sh ./common/util/generate_fpga_results.sh

.PHONY: cpu_results
cpu_results:
	sh ./common/util/generate_cpu_results.sh